<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overlord - Omkar K.</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
    <div class="container">
        <div id="header-container"></div>

        <article>
            <a href="thoughts.html" class="back-link">&larr; back</a>

            <header class="article-header">
                <h1> Project Overlord</h1>
                <div class="article-meta">
                    <span>Dec 18, 2025</span>
                    <span>&bull;</span>
                    <span>10 min read</span>
                </div>
            </header>

            <div class="article-content">
                <p>After seeing <a href="https://poke.com" target="_blank" rel="noopener noreferrer">Poke by Interaction</a> release and how it was able to control its own price autonomously, I wondered what other tools Poke could be given access to. A few months later while trying to lock in, I was left dissatisfied with productivity tools’ “blanket” coverage. They couldn’t discriminate between Youtube for Karpathy’s videos and brainrot videos. </p>

                <p>It then occurred to me that I could tie these two ideas together to engineer an agentic system that was able to discern between task-relevant and irrelevant screen content. Months went by however, with the idea collecting dust. And of course, I decided to bring Overlord to life while studying for finals What follows is a technical write-up of two weeks of learning Electron, MCP, server-client relationships, and writing most logic code by-hand for learning's sake.
                </p>
                
                <figure>
                    <img src="assets/architecture.png" alt="System architecture diagram showing server-client relationship">
                    <figcaption>Fig 1. Architecture Diagram</figcaption>
                </figure>

                <p>At a high level, Overlord consists of four components: a local Electron client, a coordinating Python server, an external agent (Poke), and OpenAI API.The architecture is intentionally minimal and can be best demonstrated with a demo walk-through.
                </p>

                <p>After a user opens the application, they are greeted with the main Overlord screen, which asks them to enter an objective (task) and duration. 
                </p>

                <figure>
                    <div class="image-row">
                        <img src="assets/main.png" alt="Overlord main screen with task input">
                        <img src="assets/timer.png" alt="Overlord timer overlay">
                    </div>
                    <figcaption>Fig 2. Main screen and timer overlay</figcaption>
                </figure>

                <p>Once initiated, the screen minimizes into a timer in the corner and overlays all applications, including full-screen ones. 
                </p>

                <p>Every 30 seconds, a screenshot is taken. Electron passes the screenshot to the server (hosted on Render), which then submits the user’s declared task plus the current screenshot to OpenAI’s 4o vision model and requests a strict binary verdict (YES/NO) as to if the user is on task. 
                </p>

                <p>If “YES”, the screenshot loop will continue until the timer runs out.
                </p>

                <p>In case that “NO” is passed to Electron, the application goes into “Kiosk Mode”, which restricts standard exit paths (Command-Q, window switching) but isn’t a kernel-level lock. 
                </p>

                <p>Shortly after, Electron does a fetch to the server, which uses the POST method /punish to tell Poke that the user is misbehaving and needs to send proof of completing X task (10 pushups in this case) before the screen will be unlocked. At this point, all that’s left is for Poke to determine that the user has completed X task, before it exercises the unlock_user() tool via MCP (Model Context Protocol), which updates the server’s locked state to false. 
                </p>

                <p>All this while, Electron has been async polling the server every 500ms (via GET requests), waiting for this. Once this happens, Electron unlocks the user’s screen and returns them to the homescreen.
                </p>

                <figure>
                    <img src="assets/lockout.png" alt="Locked screen showing violation detection">
                    <figcaption>Fig 3. Lockout screen when user goes off-task</figcaption>
                </figure>

                <figure>
                    <img src="assets/messages.png" alt="Poke messages verifying pushup completion">
                    <figcaption>Fig 4. Poke verifying task completion via messages</figcaption>
                </figure>

                <p>Decoupling Client from the Infrastructure:</p>

                <p>Halfway through making the github public, it occurred to me that I would need to allow users to use their own Poke and OpenAI API keys! To enable this and make Overlord a distributable product and not just a personal script, I implemented a dynamic configuration store (electron-store) that lets users plug in their own python server without recompiling the electron app.
                </p>

                <figure>
                    <img src="assets/settings.png" alt="Settings page for configuring server URL">
                    <figcaption>Fig 5. Dynamic configuration settings</figcaption>
                </figure>
                <h2>Technical Learnings</h2>
                <h3>Electron:</h3>
                <p>This was my first time building with Electron and learning all about IPC (Inter-Process Communication) between the Main Process and Renderer Process was pretty cool.</p>
                <div class="code-block-wrapper">
                    <button class="copy-btn" onclick="copyCode(this)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                    </button>
                    <pre><code class="language-javascript">ipcMain.on('start-focus-mode', (event, duration, task) => {
    console.log('start focus mode signal activated yuhh') 
})</code></pre>
                </div>
                <h3>Architecture:</h3>
                <p>Though I had a vision for the product before I started, drawing out some diagrams and deep diving into the differences between MCP and REST really helped iron out my thought process. Overlord uses a standard REST API for the “punishment” flow and Model Context Protocol interface for the “redemption” flow. This lets Poke mutate state directly on my server.</p>
                <h3>Distributed State Consistency</h3>
                <p>Most of my previous understanding of state was purely theoretical. This project was extremely useful in having my work with stateless and stateful components hands-on.</p>
                <div class="code-block-wrapper">
                    <button class="copy-btn" onclick="copyCode(this)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                    </button>
                    <pre><code class="language-python"># Judge class maintains the authoritative state
class Judge: 
    def __init__(self):
        self.locked = False
        self.offenses = 0
    
    def status(self):
        return {"locked": self.locked, "offenses": self.offenses}

    def punish(self):
        self.offenses += 1
        self.locked = True
        # ... trigger external consequences (Poke/SMS) ...
        return self.status()

    def forgive(self):
        self.locked = False
        return self.status()

judge = Judge()</code></pre>
                </div>
                <p>
                    After running into a minefield of race conditions, I realized I had to establish a single source of truth for state across the distributed system (Renderer, Main Process, Python Server, Poke). The python server maintains the authoritative lock state while the Electron client treats its local state as speculative and uses polling to reconcile. Poke is the only component that can mutate lock state via MCP. The React front-end is a UI that is limited to rendering what the main process dictates via IPC events.
                </p>
                <div class="code-block-wrapper">
                    <button class="copy-btn" onclick="copyCode(this)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                    </button>
                    <pre><code class="language-typescript">const scheduleNextRun = (): void => {
    if (isFocusModeActive) {
        console.log("Scheduling next check in 30s...");
        setTimeout(() => runFocusCheck(window, task), 30000);
    }
};</code></pre>
                </div>
                <p>One specific problem I ran into was using setInterval instead of setTimeout. During testing, I discovered that even when Electron went into kiosk mode and locked out the user, screenshots continued to be captured. Analysis revealed that setInterval is “fire-and-forget”, meaning that screenshots can’t be stopped! Additionally, if the network is really poor, multiple requests could be running in parallel and fighting for bandwidth leading to race conditions. Refactoring the code to use the recursive setTimeout guaranteed sequential execution and proper stoppage of screenshots.
                </p>
                <h2>Next Steps</h2>
                <h3>Migrating to Local LLMs</h3>
                <p>Yes, I’m aware that having possibly sensitive data leave the computer and into OpenAI’s hands is far from ideal. Ollama model support will be introduced ASAP. 
                </p>
                <h3>Real-Time Locking</h3>
                <p>After I finished coding up everything, I realized that I could have used websockets for real-time locking instead of polling. At this point I had already spent a lot of time fixing bugs + refactoring. Decided to prioritize shipping for now, but will come back to this hopefully soon.
                </p>
                <h3>Data Persistence</h3>
                <p>Since this app doesn’t have many data points that need to persist, I have chosen to keep it as lightweight as possible and not add a database. It would be trivial to add a database that would allow Poke to increase punishments based off of repeat offences.
                </p>
                <p>I had a lot of fun building this out! Would love for you to try it out and give me feedback! Code is live on Github.</p>



            </div>
        </article>

        <footer>
            <div class="social-links">
                <a href="https://x.com/KovvaliOmkar" target="_blank" rel="noopener noreferrer" aria-label="X (Twitter)">
                    <img src="assets/X_logo_2023.svg.png" alt="X (Twitter)">
                </a>
                <a href="https://www.linkedin.com/in/omkarkovvali/" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-linkedin"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg>
                </a>
                <a href="https://github.com/OmkarKovvali" target="_blank" rel="noopener noreferrer" aria-label="GitHub">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg>
                </a>
                <a href="https://www.instagram.com/omkar.kovvali/" target="_blank" rel="noopener noreferrer" aria-label="Instagram">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-instagram"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg>
                </a>
            </div>
        </footer>
    </div>
    <script src="script.js"></script>
    <script>
        // Initialize highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });

        // Copy code functionality
        function copyCode(button) {
            const wrapper = button.parentElement;
            const code = wrapper.querySelector('code');
            const text = code.textContent;

            const originalHTML = button.innerHTML;

            navigator.clipboard.writeText(text).then(() => {
                button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.innerHTML = originalHTML;
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                button.textContent = '✗';
                setTimeout(() => {
                    button.innerHTML = originalHTML;
                }, 2000);
            });
        }
    </script>
</body>
</html>
